// Copyright Â© 2020 David Arnold <dar@xoe.solutions>
// SPDX-License-Identifier: MIT

package entity

import (
	"fmt"
	"go/types"
	"log"
	"reflect"
	"regexp"
	"strings"

	. "github.com/dave/jennifer/jen"

	"github.com/xoe-labs/ddd-gen/pkg/gen_domain/directive"
)

// StructTag Key
var (
	structTagEntityKey = "entity"
)

// A simple regexp pattern to match tag values
var (
	structRequiredTagPattern = regexp.MustCompile(`required,([^;]+)`)
	structPrivateTagPattern  = regexp.MustCompile(`private`)
	structGetterTagPattern   = regexp.MustCompile(`getter`)
	structSetterTagPattern   = regexp.MustCompile(`setter`)
	structStringerTagPattern = regexp.MustCompile(`stringer`)
	structEqualTagPattern    = regexp.MustCompile(`equal(,reflect)?`)
)

func generate(sourceTypeName, validatorMethod, goPackagePath string, structType *types.Struct) error {
	log.Printf("Generating code for: %s.%s\n", goPackagePath, sourceTypeName)

	// Start a new file in this package
	// return fmt.Errorf(goPackage)
	f := NewFile(goPackage)

	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by 'ddd-gen domain entity', DO NOT EDIT.")


	// 1. define code region variables
	var (
		privateFlds       []*types.Var
		publicFlds        []*types.Var
		validations       []directive.Validation
		equalFlds         []directive.EqualFld
		genGetterFields   []*types.Var
		genSetterFields   []*types.Var
		genStringerFields []*types.Var
	)

	// 2. iterate over struct fields and populate those variables
	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)
		tag := reflect.StructTag(structType.Tag(i))

		// 2.1 error if pointer field encountered
		if _, ok := field.Type().(*types.Pointer); ok {
			return fmt.Errorf("%s type is a pointer - can evade validation", field.Name())
		}

		// 2.2 match and classify fields according to tags
		var private bool
		if structTagEntityKeyValue, ok := tag.Lookup(structTagEntityKey); ok {
			if matches := structGetterTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genGetterFields = append(genGetterFields, field)
			}
			if matches := structSetterTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genSetterFields = append(genSetterFields, field)
			}
			if matches := structStringerTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genStringerFields = append(genStringerFields, field)
			}

			if matches := structPrivateTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				private = true
				privateFlds = append(privateFlds, field)
			} else {
				publicFlds = append(publicFlds, field)
			}
			if requiredMatches := structRequiredTagPattern.FindStringSubmatch(structTagEntityKeyValue); requiredMatches != nil {
				if private {
					return fmt.Errorf("private field %s cannot be required", field.Name())
				}
				errMsg := requiredMatches[1]
				validations = append(validations, directive.Validation{Field: field, ErrMsg: errMsg})
			}
			if equalMatches := structEqualTagPattern.FindStringSubmatch(structTagEntityKeyValue); equalMatches != nil {
				if (len(equalMatches) > 1 && equalMatches[1] != "") {
					equalFlds = append(equalFlds, directive.EqualFld{Field: field, IsDeepEqual: true})
				} else {
					equalFlds = append(equalFlds, directive.EqualFld{Field: field, IsDeepEqual: false})
				}
			}
		} else {
			publicFlds = append(publicFlds, field)
		}
	}

	// 3. assemble methods ...

	f.Comment("Constructors ...")
	f.Line()
	directive.GenNew(f, sourceTypeName, publicFlds, validations, validatorMethod)
	directive.GenMustNew(f, sourceTypeName, publicFlds)

	f.Comment("Marshalers ...")
	f.Line()
	directive.GenUnmarshalFromRepository(f, sourceTypeName, publicFlds, privateFlds)

	f.Comment("Accessors ...")
	f.Line()
	directive.GenGetters(f, sourceTypeName, genGetterFields)
	directive.GenSetters(f, sourceTypeName, genSetterFields)

	f.Comment("Utilities ...")
	f.Line()
	directive.GenEqual(f, sourceTypeName, equalFlds)
	directive.GenStringer(f, sourceTypeName, genStringerFields)

	// Write generated file
	return f.Save(targetFilename)
}

func isPointer(s string) bool {
	return strings.HasPrefix(s, "*")
}
