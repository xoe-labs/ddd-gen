// Copyright Â© 2020 David Arnold <dar@xoe.solutions>
// SPDX-License-Identifier: MIT

package gen_domain

import (
	"fmt"
	"go/types"
	"log"
	"reflect"
	"regexp"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/xoe-labs/ddd-gen/pkg/gen_domain/generator"
)

// StructTag Key
var (
	structTagEntityKey = "entity"
)

// A simple regexp pattern to match tag values
var (
	structRequiredTagPattern = regexp.MustCompile(`required,([^;]+)`)
	structPrivateTagPattern  = regexp.MustCompile(`private`)
	structGetterTagPattern   = regexp.MustCompile(`getter`)
	structSetterTagPattern   = regexp.MustCompile(`setter`)
	structStringerTagPattern = regexp.MustCompile(`stringer`)
	structEqualTagPattern    = regexp.MustCompile(`equal(,reflect)?`)
)

func generateEntityHelperMethods(f *jen.File, typ, validatorMethod string, typStruct *types.Struct) (err error) {
	// Add a package comment, so IDEs detect files as generated
	f.PackageComment("Code generated by 'ddd-gen domain entity', DO NOT EDIT.")

	// 1. define code region variables
	var (
		privateFlds       []generator.QualField
		publicFlds        []generator.QualField
		validations       []generator.Validation
		equalFlds         []generator.EqualFld
		genGetterFields   []generator.QualField
		genSetterFields   []generator.QualField
		genStringerFields []generator.QualField
	)

	// 2. iterate over struct fields and populate those variables
	for i := 0; i < typStruct.NumFields(); i++ {
		fld := typStruct.Field(i)

		// 2.1 error if pointer field encountered
		if _, ok := fld.Type().(*types.Pointer); ok {
			return fmt.Errorf("%s type is a pointer - can evade validation", fld.Name())
		}

		field := getRelativeQualField(fld)
		tag := reflect.StructTag(typStruct.Tag(i))


		// 2.2 match and classify fields according to tags
		var private bool
		if structTagEntityKeyValue, ok := tag.Lookup(structTagEntityKey); ok {
			if matches := structGetterTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genGetterFields = append(genGetterFields, field)
			}
			if matches := structSetterTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genSetterFields = append(genSetterFields, field)
			}
			if matches := structStringerTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				genStringerFields = append(genStringerFields, field)
			}

			if matches := structPrivateTagPattern.FindStringSubmatch(structTagEntityKeyValue); matches != nil {
				private = true
				privateFlds = append(privateFlds, field)
			} else {
				publicFlds = append(publicFlds, field)
			}
			if requiredMatches := structRequiredTagPattern.FindStringSubmatch(structTagEntityKeyValue); requiredMatches != nil {
				if private {
					return fmt.Errorf("private field %s cannot be required", field.Id)
				}
				errMsg := requiredMatches[1]
				validations = append(validations, generator.Validation{Field: field, ErrMsg: errMsg})
			}
			if equalMatches := structEqualTagPattern.FindStringSubmatch(structTagEntityKeyValue); equalMatches != nil {
				if len(equalMatches) > 1 && equalMatches[1] != "" {
					equalFlds = append(equalFlds, generator.EqualFld{Field: field, IsDeepEqual: true})
				} else {
					equalFlds = append(equalFlds, generator.EqualFld{Field: field, IsDeepEqual: false})
				}
			}
		} else {
			publicFlds = append(publicFlds, field)
		}
	}

	// 3. assemble methods ...

	f.Comment("Constructors ...")
	f.Line()
	generator.GenNew(f, typ, publicFlds, validations, validatorMethod)
	generator.GenMustNew(f, typ, publicFlds)

	f.Comment("Marshalers ...")
	f.Line()
	generator.GenUnmarshalFromStore(f, typ, publicFlds, privateFlds)

	f.Comment("Accessors ...")
	f.Line()
	generator.GenGetters(f, typ, genGetterFields)
	generator.GenSetters(f, typ, genSetterFields)

	f.Comment("Utilities ...")
	f.Line()
	generator.GenEqual(f, typ, equalFlds)
	generator.GenStringer(f, typ, genStringerFields)

	// Write generated file
	return nil
}

func generateEntityApplyStub(g *jen.Group, typ string) {
	_ = generator.GenApplyStub(g, typ)
}

func isPointer(s string) bool {
	return strings.HasPrefix(s, "*")
}

func getRelativeQualField(field *types.Var) generator.QualField {
	return generator.QualField{
		Id:      field.Name(),
		QualTyp: getQualifiedJenType(field.Type()),
	}
}

func getQualifiedJenType(ft types.Type) *jen.Statement {
	switch t := ft.(type) {
	case *types.Basic:
		return jen.Id(t.Name())
	case *types.Array:
		return jen.Index().Add(getQualifiedJenType(t.Elem()))
	case *types.Slice:
		return jen.Index().Add(getQualifiedJenType(t.Elem()))
	case *types.Map:
		return jen.Map(getQualifiedJenType(t.Key())).Add(getQualifiedJenType(t.Elem()))
	case *types.Named:
		return jen.Qual(
			t.Obj().Pkg().Path(),
			t.Obj().Name(),
		)
	default:
		log.Printf("Unsupported field type: %v\n", ft)
		return jen.Id("nil")
	}
}
