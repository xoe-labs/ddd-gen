// Code generated by 'ddd-gen app command': DO NOT EDIT.

package command

import (
	"context"
	errwrap "github.com/hashicorp/errwrap"
	errors "github.com/xoe-labs/ddd-gen/internal/test-svc/app/errors"
	offers "github.com/xoe-labs/ddd-gen/internal/test-svc/app/ifaces/offers"
	requires "github.com/xoe-labs/ddd-gen/internal/test-svc/app/ifaces/requires"
	"reflect"
)

// Topic: Holder

var (
	// ErrValidateHolderHasNoTarget signals that ValidateHolder's target was not distinguishable
	ErrValidateHolderHasNoTarget = errors.NewTargetIdentificationError("ErrValidateHolderHasNoTarget")
	// ErrValidateHolderLoadingFailed signals that ValidateHolder storage failed to load the entity
	ErrValidateHolderLoadingFailed = errors.NewStorageLoadingError("ErrValidateHolderLoadingFailed")
	// ErrValidateHolderSavingFailed signals that ValidateHolder failed to save the entity
	ErrValidateHolderSavingFailed = errors.NewStorageSavingError("ErrValidateHolderSavingFailed")
	// ErrValidateHolderFailedInDomain signals that ValidateHolder failed in the domain layer
	ErrValidateHolderFailedInDomain = errors.NewDomainError("ErrValidateHolderFailedInDomain")
)

// ValidateHolderHandlerWrapper knows how to perform ValidateHolder
type ValidateHolderHandlerWrapper struct {
	rw requires.StorageWriterReader
}

// NewValidateHolderHandlerWrapper returns ValidateHolderHandlerWrapper
func NewValidateHolderHandlerWrapper(rw requires.StorageWriterReader) *ValidateHolderHandlerWrapper {
	if reflect.ValueOf(rw).IsZero() {
		panic("no 'rw' provided!")
	}
	return &ValidateHolderHandlerWrapper{rw: rw}
}

// Handle generically performs ValidateHolder
func (h ValidateHolderHandlerWrapper) Handle(ctx context.Context, vh requires.DomainCommandHandler, actor offers.Policeable, target offers.Distinguishable) error {
	// assert that target is distinguishable
	if !target.IsDistinguishable() {
		return ErrValidateHolderHasNoTarget
	}
	// load entity from store; handle + wrap error
	a, loadErr := h.rw.Load(ctx, target)
	if loadErr != nil {
		return errwrap.Wrap(ErrValidateHolderLoadingFailed, loadErr)
	}
	// assert correct command handling by the domain
	if ok := vh.Handle(ctx, a); !ok {
		var domErr error
		// vh is an ErrorKeeper
		for i, e := range vh.Errors() {
			if i == 0 {
				domErr = e
			} else {
				domErr = errwrap.Wrap(domErr, e)
			}
		}
		return ErrValidateHolderFailedInDomain
	}
	// save domain facts to storage
	saveErr := h.rw.SaveFacts(ctx, target, requires.FactKeeper(vh))
	if saveErr != nil {
		return errwrap.Wrap(ErrValidateHolderSavingFailed, saveErr)
	}
	return nil
}
