// Code generated by 'ddd-gen app command': DO NOT EDIT.

package command

import (
	"context"
	"encoding/json"
	errwrap "github.com/hashicorp/errwrap"
	error1 "github.com/xoe-labs/ddd-gen/internal/test-svc/app/error"
	policy "github.com/xoe-labs/ddd-gen/internal/test-svc/app/policy"
	repository "github.com/xoe-labs/ddd-gen/internal/test-svc/app/repository"
	account "github.com/xoe-labs/ddd-gen/internal/test-svc/domain/account"
	"reflect"
)

// Topic: Account

var (
	// ErrNotAuthorizedToBlockAccount signals that the caller is not authorized to perform BlockAccount
	ErrNotAuthorizedToBlockAccount = error1.NewAuthorizationError("ErrNotAuthorizedToBlockAccount")
	// ErrBlockAccountNotIdentifiable signals that BlockAccount's command object was not identifiable
	ErrBlockAccountNotIdentifiable = error1.NewIdentificationError("ErrBlockAccountNotIdentifiable")
	// ErrBlockAccountFailedInRepository signals that BlockAccount failed in the repository layer
	ErrBlockAccountFailedInRepository = error1.NewRepositoryError("ErrBlockAccountFailedInRepository")
	// ErrBlockAccountFailedInDomain signals that BlockAccount failed in the domain layer
	ErrBlockAccountFailedInDomain = error1.NewDomainError("ErrBlockAccountFailedInDomain")
)

// BlockAccountHandler knows how to perform BlockAccount
type BlockAccountHandler struct {
	pol policy.Policer
	agg repository.Repository
}

// NewBlockAccountHandler returns BlockAccountHandler
func NewBlockAccountHandler(pol policy.Policer, agg repository.Repository) *BlockAccountHandler {
	if reflect.ValueOf(pol).IsZero() {
		panic("no 'pol' provided!")
	}
	if reflect.ValueOf(agg).IsZero() {
		panic("no 'agg' provided!")
	}
	return &BlockAccountHandler{pol: pol, agg: agg}
}

// Handle generically performs BlockAccount
func (h BlockAccountHandler) Handle(ctx context.Context, ba BlockAccount) error {
	if reflect.ValueOf(ba.Identifier()).IsZero() {
		return ErrBlockAccountNotIdentifiable
	}
	var innerErr error
	var repoErr error
	repoErr = h.agg.Update(ctx, ba, func(a *account.Account) bool {
		data, err := json.Marshal(a)
		if err != nil {
			panic(err) // invariant violation: the domain shall always be consistent!
		}
		if ok := h.pol.Can(ctx, ba, "BlockAccount", data); !ok {
			innerErr = ErrNotAuthorizedToBlockAccount
			return false
		}
		if err := ba.handle(ctx, a); err != nil {
			innerErr = errwrap.Wrap(ErrBlockAccountFailedInDomain, err)
			return false
		}
		return true
	})
	if innerErr != nil {
		return innerErr
	}
	if repoErr != nil {
		return errwrap.Wrap(ErrBlockAccountFailedInRepository, repoErr)
	}
	return nil
}
