// Code generated by 'ddd-gen app command': DO NOT EDIT.

package command

import (
	"context"
	errwrap "github.com/hashicorp/errwrap"
	errors "github.com/xoe-labs/ddd-gen/internal/test-svc/app/errors"
	ifaces "github.com/xoe-labs/ddd-gen/internal/test-svc/app/ifaces"
	offers "github.com/xoe-labs/ddd-gen/internal/test-svc/app/ifaces/offers"
	requires "github.com/xoe-labs/ddd-gen/internal/test-svc/app/ifaces/requires"
	"reflect"
)

// Topic: Balance

var (
	// ErrNotAuthorizedToIncreaseBalanceFromSvc signals that the caller is not authorized to perform IncreaseBalanceFromSvc
	ErrNotAuthorizedToIncreaseBalanceFromSvc = errors.NewAuthorizationError("ErrNotAuthorizedToIncreaseBalanceFromSvc")
	// ErrIncreaseBalanceFromSvcHasNoTarget signals that IncreaseBalanceFromSvc's target was not distinguishable
	ErrIncreaseBalanceFromSvcHasNoTarget = errors.NewTargetIdentificationError("ErrIncreaseBalanceFromSvcHasNoTarget")
	// ErrIncreaseBalanceFromSvcLoadingFailed signals that IncreaseBalanceFromSvc storage failed to load the entity
	ErrIncreaseBalanceFromSvcLoadingFailed = errors.NewStorageLoadingError("ErrIncreaseBalanceFromSvcLoadingFailed")
	// ErrIncreaseBalanceFromSvcSavingFailed signals that IncreaseBalanceFromSvc failed to save the entity
	ErrIncreaseBalanceFromSvcSavingFailed = errors.NewStorageSavingError("ErrIncreaseBalanceFromSvcSavingFailed")
	// ErrIncreaseBalanceFromSvcFailedInDomain signals that IncreaseBalanceFromSvc failed in the domain layer
	ErrIncreaseBalanceFromSvcFailedInDomain = errors.NewDomainError("ErrIncreaseBalanceFromSvcFailedInDomain")
)

// IncreaseBalanceFromSvcHandlerWrapper knows how to perform IncreaseBalanceFromSvc
type IncreaseBalanceFromSvcHandlerWrapper struct {
	rw  requires.StorageWriterReader
	p   requires.Policer
	svc ifaces.Balancer
}

// NewIncreaseBalanceFromSvcHandlerWrapper returns IncreaseBalanceFromSvcHandlerWrapper
func NewIncreaseBalanceFromSvcHandlerWrapper(svc ifaces.Balancer, rw requires.StorageWriterReader, p requires.Policer) *IncreaseBalanceFromSvcHandlerWrapper {
	if reflect.ValueOf(svc).IsZero() {
		panic("no 'svc' provided!")
	}
	if reflect.ValueOf(rw).IsZero() {
		panic("no 'rw' provided!")
	}
	if reflect.ValueOf(p).IsZero() {
		panic("no 'p' provided!")
	}
	return &IncreaseBalanceFromSvcHandlerWrapper{svc: svc, rw: rw, p: p}
}

// Handle generically performs IncreaseBalanceFromSvc
func (h IncreaseBalanceFromSvcHandlerWrapper) Handle(ctx context.Context, ibfs requires.DomainCommandHandler, actor offers.Policeable, target offers.Distinguishable) error {
	// assert that target is distinguishable
	if !target.IsDistinguishable() {
		return ErrIncreaseBalanceFromSvcHasNoTarget
	}
	// load entity from store; handle + wrap error
	a, loadErr := h.rw.Load(ctx, target)
	if loadErr != nil {
		return errwrap.Wrap(ErrIncreaseBalanceFromSvcLoadingFailed, loadErr)
	}
	// assert authorization via policy interface
	if ok := h.p.Can(ctx, actor, "IncreaseBalanceFromSvc", a); !ok {
		// return opaque error: handle potentially sensitive policy errors out-of-band!
		return ErrNotAuthorizedToIncreaseBalanceFromSvc
	}
	// assert correct command handling by the domain
	if ok := ibfs.Handle(ctx, a, &h.svc); !ok {
		var domErr error
		// ibfs is an ErrorKeeper
		for i, e := range ibfs.Errors() {
			if i == 0 {
				domErr = e
			} else {
				domErr = errwrap.Wrap(domErr, e)
			}
		}
		return ErrIncreaseBalanceFromSvcFailedInDomain
	}
	// save domain facts to storage
	saveErr := h.rw.SaveFacts(ctx, target, requires.FactKeeper(ibfs))
	if saveErr != nil {
		return errwrap.Wrap(ErrIncreaseBalanceFromSvcSavingFailed, saveErr)
	}
	return nil
}
